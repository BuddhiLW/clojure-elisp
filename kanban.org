#+TITLE: ClojureElisp Development Kanban
#+STARTUP: overview
#+TODO: TODO IN-PROGRESS IN-REVIEW | DONE CANCELLED

* Backlog
** DONE Add more predicate functions to runtime
:PROPERTIES:
:ID: clel-014
:PRIORITY: C
:END:
- zero?, pos?, neg?, even?, odd? → zerop, cl-plusp, cl-minusp, cl-evenp, cl-oddp
- some?, true?, false? → clel-some-p, clel-true-p, clel-false-p
- coll?, sequential?, associative? → clel-coll-p, clel-sequential-p, clel-associative-p
- 90 tests, 556 assertions total

** DONE Implement atom watch functions
:PROPERTIES:
:ID: clel-015
:PRIORITY: C
:END:
- add-watch, remove-watch for atoms
- Updated atom structure to store watchers alist
- clel-add-watch, clel-remove-watch, clel--notify-watchers
- Updated clel-reset!, clel-swap! to notify watchers
- 94 tests, 595 assertions total

** TODO Add CLI compilation tool
:PROPERTIES:
:ID: clel-016
:PRIORITY: C
:END:
clojure -M:compile src/foo.cljel -o out/foo.el
- Parse command line args
- Support directory compilation
- Watch mode for development

** TODO Create cljel-mode for Emacs
:PROPERTIES:
:ID: clel-017
:PRIORITY: C
:END:
Major mode for editing .cljel files
- Inherit from clojure-mode
- Add compile command integration
- REPL integration

** TODO Implement lazy sequences
:PROPERTIES:
:ID: clel-018
:PRIORITY: C
:END:
lazy-seq, realized?, doall, dorun
May need thunk-based approach in Elisp

** TODO Add metadata support
:PROPERTIES:
:ID: clel-019
:PRIORITY: C
:END:
^:private, ^:dynamic, ^:const
Store in symbol plist in Elisp

** TODO Source location tracking
:PROPERTIES:
:ID: clel-020
:PRIORITY: C
:END:
Track line/column in AST nodes for better error messages
Optionally emit comments with source locations

** TODO Elisp interop — dot-notation and native Emacs API calls
:PROPERTIES:
:ID: clel-021
:PRIORITY: B
:END:
Add Elisp interop so ClojureElisp can call Emacs APIs directly.
- (. obj method args), (.method obj args) sugar
- (elisp/function args) namespace-qualified calls emitting raw Elisp
- Analyzer: recognize interop forms
- Emitter: emit direct Elisp function calls
- Tests: buffer-name, message, car/cdr, interactive APIs
Depends on: nothing (foundational)

** TODO Basic REPL — comint-based compile-and-eval loop
:PROPERTIES:
:ID: clel-022
:PRIORITY: B
:END:
Basic REPL: read forms, compile to Elisp via JVM, eval in Emacs.
- comint-mode buffer
- Send form to running clojure process via stdin
- Receive compiled Elisp, eval locally, display result
Depends on: clel-017 (mode)

** TODO nREPL middleware + CIDER integration
:PROPERTIES:
:ID: clel-023
:PRIORITY: B
:END:
nREPL middleware intercepts eval ops for :cljel session type.
- Compiles via clojure-elisp.core, returns Elisp string
- CIDER side: register :cljel REPL type
- Local eval of compiled Elisp in Emacs, result display
Depends on: clel-022 (basic REPL)

** TODO Port hive-mcp modules to ClojureElisp (incremental)
:PROPERTIES:
:ID: clel-024
:PRIORITY: C
:END:
Incrementally port hive-mcp Elisp modules to ClojureElisp.
- Start with self-contained utility module
- Compile to .el, require alongside existing Elisp
- Validate interop and runtime work end-to-end
Depends on: clel-021 (interop), clel-017 (mode)

* In Progress

* In Review

* Done
** DONE Initial compiler infrastructure
:PROPERTIES:
:ID: clel-100
:END:
- Analyzer with basic special forms
- Emitter with AST->Elisp transformation
- Core API (emit, compile-file, compile-ns)
- Runtime library with collection ops

** DONE Add macroexpansion for threading macros
:PROPERTIES:
:ID: clel-101
:END:
->, ->>, and other macros now expand before analysis

** DONE Add test infrastructure with Kaocha
:PROPERTIES:
:ID: clel-001
:END:
- Created tests.edn with Kaocha configuration
- test/clojure_elisp/analyzer_test.clj (25 tests)
- test/clojure_elisp/emitter_test.clj (28 tests)
- test/clojure_elisp/core_test.clj (14 tests)
- Total: 67 tests, 349 assertions

** DONE Implement destructuring in let bindings
:PROPERTIES:
:ID: clel-002
:END:
- Vector destructuring: [a b], [a & rest], [:as all]
- Map destructuring: {:keys [x y]}, {:strs [a]}, {:or {x 0}}, {:as m}
- Nested destructuring supported
- Added expand-destructuring, expand-vector-destructuring, expand-map-destructuring

** DONE Add try/catch/finally support
:PROPERTIES:
:ID: clel-004
:END:
- Analyzer: analyze-try handles try/catch/finally forms
- Emitter: emits condition-case for catch, unwind-protect for finally
- (try ... (catch E e ...) (finally ...)) works correctly

** DONE Implement destructuring in fn/defn parameters
:PROPERTIES:
:ID: clel-003
:END:
- Support & rest args: (defn foo [a & rest] ...)
- Emits (&rest args) with nthcdr for rest param

** DONE Add throw support
:PROPERTIES:
:ID: clel-005
:END:
- analyze-throw detects ex-info, Exception., rethrow patterns
- Emits (signal 'error ...) in Elisp

** DONE Support multi-arity functions
:PROPERTIES:
:ID: clel-006
:END:
- Detect: (defn foo ([x] x) ([x y] (+ x y)))
- Emit cl-case dispatch on (length args)
- 71 tests, 395 assertions

** DONE Implement case special form
:PROPERTIES:
:ID: clel-007
:END:
- (case x :a 1 :b 2 :default) → (cl-case x (:a 1) (:b 2) (t :default))
- Analyzer handles test-val/expr pairs with optional default
- Emitter produces cl-case with proper clause formatting

** DONE Implement letfn for local functions
:PROPERTIES:
:ID: clel-008
:END:
- (letfn [(foo [x] ...) (bar [y] ...)] body) → cl-labels
- Supports mutual recursion between local functions
- Function names added to env before analyzing bodies

** DONE Handle and/or as special forms
:PROPERTIES:
:ID: clel-010
:END:
- Removed from core-fn-mapping, now proper special forms
- Short-circuit evaluation using native Elisp and/or
- Empty (and) → t, empty (or) → nil (Clojure semantics)
- 79 tests, 449 assertions

** DONE Implement defmulti/defmethod
:PROPERTIES:
:ID: clel-009
:END:
- Analyzer: analyze-defmulti, analyze-defmethod added
- Emitter: cl-defgeneric for defmulti, cl-defmethod with eql type dispatch
- :default dispatch maps to t (catch-all)
- Destructuring in defmethod params supported

** DONE Proper namespace :require handling
:PROPERTIES:
:ID: clel-011
:END:
- parse-require-spec handles :as, :refer options
- analyze-ns extracts :requires from ns form
- Emitter uses parsed requires for (require 'ns) statements
- Supports multiple require clauses

** DONE Add clel-into to runtime
:PROPERTIES:
:ID: clel-012
:END:
- clel-into function in clojure-elisp-runtime.el
- Supports vectors (into [] coll), lists (into '() coll), hash-tables
- 86 tests, 509 assertions total

** DONE Add clel-dissoc to runtime
:PROPERTIES:
:ID: clel-013
:END:
- clel-dissoc removes key from alist or hash-table
- Uses cl-remove-if for alists, remhash for hash-tables
- 87 tests, 520 assertions total

* Cancelled
